package codegen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"

	"github.com/beevik/etree"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var (
	ErrMissingProtocolInfo = errors.New("codegen: failed to locate protocol info")
	ErrMissingRecords      = errors.New("codegen: failed to locate records")
	ErrInvalidRecord       = errors.New("codegen: record is not valid")
	ErrInvalidMessage      = errors.New("codegen: message is not valid")
	ErrNoGoPackageEnv      = errors.New("codegen: $GOPACKAGE was not set in environment")
)

var (
	lowerCaser   = cases.Title(language.English)
	noLowerCaser = cases.Title(language.English, cases.NoLower)
)

type Field struct {
	Name string
	Type string
}

type Message struct {
	Type string
	Meta struct {
		MsgOrder       string
		MsgName        string
		MsgDescription string
		MsgHandler     string
		MsgAccessLvl   string
	}
	Fields []Field
}

type Protocol struct {
	Package string
	Service string
	Meta    struct {
		ServiceID   string
		Type        string
		Version     string
		Description string
	}
	Messages []Message
}

var outBuf bytes.Buffer

func Generate(w io.Writer, messagesPath string) error {
	doc := etree.NewDocument()

	if err := doc.ReadFromFile(messagesPath); err != nil {
		return err
	}

	var p Protocol
	if err := readProtocol(doc, &p); err != nil {
		return err
	}

	write("// Code generated by go-dml-codegen. DO NOT EDIT.")
	write("package ", p.Package)

	write("import (")
	write(`"`, "github.com/cedws/go-dml-codegen/proto", `"`)
	write(`"bytes"`)
	write(`"encoding/binary"`)
	write(")")

	write("type ", unexport(p.Service), "Service interface {")
	for _, msg := range p.Messages {
		write(msg.Type, "(", msg.Type, ")")
	}
	write("}")

	write("type ", unexport(p.Service), "Client interface {")
	for _, msg := range p.Messages {
		write(msg.Type, "(", msg.Type, ") error")
	}
	write("}")

	write()

	write("type ", p.Service, "Service struct {")
	write(unexport(p.Service), "Service")
	write("}")

	for _, msg := range p.Messages {
		write("func (l *", p.Service, "Service) ", msg.Type, "(_ ", msg.Type, ") {}")
	}

	write()

	write("func Register", p.Service, "Service(r *proto.MessageRouter, s ", unexport(p.Service), "Service) {")
	for _, msg := range p.Messages {
		write("\t", "proto.RegisterMessageHandler(r, ", p.Meta.ServiceID, ",", msg.Meta.MsgOrder, ",", "s.", msg.Type, ")")
	}
	write("}")

	writeMessages(p)

	if err := reformat(&outBuf, w); err != nil {
		return err
	}

	return nil
}

func writeMessages(p Protocol) {
	for _, msg := range p.Messages {
		write("type ", msg.Type, " struct {")
		for _, field := range msg.Fields {
			write(field.Name, " ", field.Type)
		}
		write("}")

		generateMarshalBinary(msg)
		generateUnmarshalBinary(msg)
	}
}

func generateMarshalBinary(msg Message) {
	write("func (s *", msg.Type, ") MarshalBinary() ([]byte, error) {")
	write("var buf bytes.Buffer")

	if generateStringFunc(msg.Fields) {
		write("writeString := func(v string) {")
		write("binary.Write(&buf, binary.LittleEndian, uint16(len(v)))")
		write("buf.WriteString(v)")
		write("}")
	}

	for _, field := range msg.Fields {
		switch field.Type {
		case "string":
			write("writeString(s.", field.Name, ")")
		default:
			write("binary.Write(&buf, binary.LittleEndian, s.", field.Name, ")")
		}

	}

	write("return buf.Bytes(), nil")
	write("}")
}

func generateUnmarshalBinary(msg Message) {
	write("func (s *", msg.Type, ") UnmarshalBinary(data []byte) error {")

	if len(msg.Fields) == 0 {
		write("return nil")
		write("}")

		return
	}

	write("buf := bytes.NewReader(data)")
	write("var err error")

	if generateStringFunc(msg.Fields) {
		write("readString := func() (string, error) {")
		write("var length uint16")
		write("if err := binary.Read(buf, binary.LittleEndian, &length); err != nil {")
		write(`return "", err`)
		write("}")
		write("data := make([]byte, length)")
		write("if _, err := buf.Read(data); err != nil {")
		write(`return "", err`)
		write("}")
		write("return string(data), nil")
		write("}")
	}

	for _, field := range msg.Fields {
		switch field.Type {
		case "string":
			write("if s.", field.Name, ", err = readString(); err != nil {")
			write("return err")
			write("}")
		default:
			write("if err = binary.Read(buf, binary.LittleEndian, &s.", field.Name, "); err != nil {")
			write("return err")
			write("}")
		}
	}

	write("return nil")
	write("}")
}

func generateStringFunc(fields []Field) bool {
	for _, field := range fields {
		if field.Type == "string" {
			return true
		}
	}

	return false
}

func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func write(args ...string) {
	fmt.Fprintln(&outBuf, strings.Join(args, ""))
}

func reformat(in *bytes.Buffer, out io.Writer) error {
	fmtd, err := format.Source(in.Bytes())
	if err != nil {
		return err
	}

	_, err = out.Write(fmtd)
	return err
}

func readProtocol(doc *etree.Document, p *Protocol) error {
	p.Package = os.Getenv("GOPACKAGE")
	if p.Package == "" {
		return ErrNoGoPackageEnv
	}

	if err := readProtocolInfo(doc, p); err != nil {
		return err
	}

	if err := readMessages(doc, p); err != nil {
		return err
	}

	return nil
}

func readMessages(doc *etree.Document, p *Protocol) error {
	records := doc.FindElements("//RECORD")
	if records == nil {
		return ErrMissingRecords
	}

	if len(records) == 0 {
		return ErrInvalidRecord
	}

	// Skip first record which is protocol info
	for n, record := range records[1:] {
		fields := record.FindElements("*")
		if fields == nil {
			return ErrInvalidRecord
		}

		var msg Message

		for _, field := range fields {
			txt := field.Text()

			switch field.Tag {
			case "_MsgOrder":
				msg.Meta.MsgOrder = txt
			case "_MsgName":
				msg.Meta.MsgName = txt
			case "_MsgDescription":
				msg.Meta.MsgDescription = txt
			case "_MsgHandler":
				// Use the handler name as the message type because it's already PascalCased for us
				msg.Type = strings.ReplaceAll(txt[4:], "_", "")
				msg.Meta.MsgHandler = txt
			case "_MsgAccessLvl":
				msg.Meta.MsgAccessLvl = txt
			default:
				attr := field.SelectAttr("TYPE")
				if attr == nil {
					continue
				}

				field := Field{
					Name: noLowerCaser.String(field.Tag),
					Type: dmlToGoType(attr.Value),
				}

				msg.Fields = append(msg.Fields, field)
			}
		}

		// Default to using the index of the message as the MsgOrder if unspecified
		if msg.Meta.MsgOrder == "" {
			msg.Meta.MsgOrder = fmt.Sprint(n + 1)
		}

		p.Messages = append(p.Messages, msg)
	}

	return nil
}

func readProtocolInfo(doc *etree.Document, p *Protocol) error {
	record := doc.FindElement("//_ProtocolInfo/RECORD")
	if record == nil {
		return ErrMissingProtocolInfo
	}

	search := map[string]string{
		"ServiceID":           "",
		"ProtocolType":        "",
		"ProtocolVersion":     "",
		"ProtocolDescription": "",
	}
	for k := range search {
		val := record.FindElement(k)
		if val == nil {
			return ErrMissingProtocolInfo
		}
		search[k] = val.Text()
	}

	p.Meta.ServiceID = search["ServiceID"]
	p.Meta.Type = search["ProtocolType"]
	p.Meta.Version = search["ProtocolVersion"]
	p.Meta.Description = search["ProtocolDescription"]

	p.Service = lowerCaser.String(p.Meta.Type)

	return nil
}

func dmlToGoType(typ string) string {
	switch typ {
	case "BYT":
		return "int8"
	case "UBYT":
		return "uint8"
	case "SHRT":
		return "int16"
	case "USHRT":
		return "uint16"
	case "INT":
		return "int32"
	case "UINT":
		return "uint32"
	case "STR":
		return "string"
	case "WSTR":
		// TODO: Think about this
		return "string"
	case "FLT":
		return "float32"
	case "DBL":
		return "float64"
	case "GID":
		return "uint64"
	default:
		// TODO: Don't panic!
		panic(fmt.Sprintf("unknown DML type %v", typ))
	}
}
