package codegen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"

	"github.com/beevik/etree"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var (
	ErrMissingProtocolInfo = errors.New("codegen: failed to locate protocol info")
	ErrMissingRecords      = errors.New("codegen: failed to locate records")
	ErrInvalidRecord       = errors.New("codegen: record is not valid")
	ErrInvalidMessage      = errors.New("codegen: message is not valid")
	ErrNoGoPackageEnv      = errors.New("codegen: $GOPACKAGE was not set in environment")
)

var (
	lowerCaser   = cases.Title(language.English)
	noLowerCaser = cases.Title(language.English, cases.NoLower)
)

type Field struct {
	Name string
	Type string
}

type Message struct {
	Type string
	Meta struct {
		MsgOrder       string
		MsgName        string
		MsgDescription string
		MsgHandler     string
		MsgAccessLvl   string
	}
	Fields []Field
}

type Protocol struct {
	Package string
	Service string
	Meta    struct {
		ServiceID   string
		Type        string
		Version     string
		Description string
	}
	Messages []Message
}

func ReadProtocol(file string) (Protocol, error) {
	doc := etree.NewDocument()

	if err := doc.ReadFromFile(file); err != nil {
		return Protocol{}, err
	}

	var pr Protocol
	if err := readProtocol(doc, &pr); err != nil {
		return Protocol{}, err
	}

	return pr, nil
}

func Generate(w io.Writer, pr Protocol) error {
	var b bytes.Buffer

	p(&b, "// Code generated by go-dml-codegen. DO NOT EDIT.")
	p(&b, "package ", pr.Package)

	p(&b, "import (")
	p(&b, `"`, "github.com/cedws/go-dml-codegen/proto", `"`)
	p(&b, `"bytes"`)
	p(&b, `"encoding/binary"`)
	p(&b, `"unsafe"`)
	p(&b, ")")

	p(&b, "type ", unexport(pr.Service), "Service interface {")
	for _, msg := range pr.Messages {
		p(&b, msg.Type, "(", msg.Type, ")")
	}
	p(&b, "}")

	p(&b, "type ", unexport(pr.Service), "Client interface {")
	for _, msg := range pr.Messages {
		p(&b, msg.Type, "(", msg.Type, ") error")
	}
	p(&b, "}")

	p(&b)

	p(&b, "type ", pr.Service, "Service struct {")
	p(&b, unexport(pr.Service), "Service")
	p(&b, "}")

	p(&b, "type ", pr.Service, "Client struct {")
	p(&b, "c *proto.Client")
	p(&b, "}")

	for _, msg := range pr.Messages {
		p(&b, "func (l *", pr.Service, "Service) ", msg.Type, "(_ ", msg.Type, ") {}")
	}

	p(&b)

	p(&b, "func Register", pr.Service, "Service(r *proto.MessageRouter, s ", unexport(pr.Service), "Service) {")
	for _, msg := range pr.Messages {
		p(&b, "proto.RegisterMessageHandler(r, ", pr.Meta.ServiceID, ",", msg.Meta.MsgOrder, ",", "s.", msg.Type, ")")
	}
	p(&b, "}")

	p(&b, "func New", pr.Service, "Client(c *proto.Client) ", pr.Service, "Client {")
	p(&b, "return ", pr.Service, "Client{c}")
	p(&b, "}")

	for _, msg := range pr.Messages {
		p(&b, "func (c ", pr.Service, "Client) ", msg.Type, "(m *", msg.Type, ") error {")
		p(&b, "return c.c.WriteMessage(", pr.Meta.ServiceID, ",", msg.Meta.MsgOrder, ", m)")
		p(&b, "}")
	}

	writeMessages(&b, pr)
	writeFuncs(&b, pr)

	if err := reformat(&b, w); err != nil {
		return err
	}

	return nil
}

func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func p(w io.Writer, args ...string) {
	fmt.Fprintln(w, strings.Join(args, ""))
}

func reformat(in *bytes.Buffer, out io.Writer) error {
	fmtd, err := format.Source(in.Bytes())
	if err != nil {
		return err
	}

	_, err = out.Write(fmtd)
	return err
}

func writeMessages(b io.Writer, pr Protocol) {
	for _, msg := range pr.Messages {
		p(b, "type ", msg.Type, " struct {")
		for _, field := range msg.Fields {
			p(b, field.Name, " ", field.Type)
		}
		p(b, "}")

		generateMarshalBinary(b, pr, msg)
		generateUnmarshalBinary(b, pr, msg)
	}
}

func generateMarshalBinary(b io.Writer, pr Protocol, msg Message) {
	p(b, "func (s *", msg.Type, ") MarshalBinary() ([]byte, error) {")
	p(b, "var b bytes.Buffer")

	for _, field := range msg.Fields {
		switch field.Type {
		case "string":
			p(b, "writeString_", pr.Meta.ServiceID, "(&b, s.", field.Name, ")")
		default:
			p(b, "binary.Write(&b, binary.LittleEndian, s.", field.Name, ")")
		}

	}

	p(b, "return b.Bytes(), nil")
	p(b, "}")
}

func generateUnmarshalBinary(b io.Writer, pr Protocol, msg Message) {
	p(b, "func (s *", msg.Type, ") UnmarshalBinary(data []byte) error {")

	if len(msg.Fields) == 0 {
		p(b, "return nil")
		p(b, "}")

		return
	}

	p(b, "b := bytes.NewReader(data)")
	p(b, "var err error")

	for _, field := range msg.Fields {
		switch field.Type {
		case "string":
			p(b, "if s.", field.Name, ", err = readString_", pr.Meta.ServiceID, "(b); err != nil {")
			p(b, "return err")
			p(b, "}")
		default:
			p(b, "if err = binary.Read(b, binary.LittleEndian, &s.", field.Name, "); err != nil {")
			p(b, "return err")
			p(b, "}")
		}
	}

	p(b, "return nil")
	p(b, "}")
}

func writeFuncs(b io.Writer, pr Protocol) {
	// funcs are prefixed with service ID to avoid conflicts when multiple files are generated
	// within the same go package

	p(b, "func writeString_", pr.Meta.ServiceID, "(b *bytes.Buffer, v string) {")
	p(b, "binary.Write(b, binary.LittleEndian, uint16(len(v)))")
	p(b, "b.WriteString(v)")
	p(b, "}")

	p(b, "func readString_", pr.Meta.ServiceID, "(buf *bytes.Reader) (string, error) {")
	p(b, "var length uint16")
	p(b, "if err := binary.Read(buf, binary.LittleEndian, &length); err != nil {")
	p(b, "return ``, err")
	p(b, "}")
	p(b, "data := make([]byte, length)")
	p(b, "if _, err := buf.Read(data); err != nil {")
	p(b, "return ``, err")
	p(b, "}")
	p(b, "return *(*string)(unsafe.Pointer(&data)), nil")
	p(b, "}")
}

func readProtocol(doc *etree.Document, p *Protocol) error {
	p.Package = os.Getenv("GOPACKAGE")
	if p.Package == "" {
		return ErrNoGoPackageEnv
	}

	if err := readProtocolInfo(doc, p); err != nil {
		return err
	}

	if err := readMessages(doc, p); err != nil {
		return err
	}

	return nil
}

func readMessages(doc *etree.Document, p *Protocol) error {
	records := doc.FindElements("//RECORD")
	if records == nil {
		return ErrMissingRecords
	}

	if len(records) == 0 {
		return ErrInvalidRecord
	}

	// Skip first record which is protocol info
	for n, record := range records[1:] {
		fields := record.FindElements("*")
		if fields == nil {
			return ErrInvalidRecord
		}

		var msg Message

		for _, field := range fields {
			txt := field.Text()

			switch field.Tag {
			case "_MsgOrder":
				msg.Meta.MsgOrder = txt
			case "_MsgName":
				msg.Meta.MsgName = txt
			case "_MsgDescription":
				msg.Meta.MsgDescription = txt
			case "_MsgHandler":
				// Use the handler name as the message type because it's already PascalCased for us
				msg.Type = strings.ReplaceAll(txt[4:], "_", "")
				msg.Meta.MsgHandler = txt
			case "_MsgAccessLvl":
				msg.Meta.MsgAccessLvl = txt
			default:
				attr := field.SelectAttr("TYPE")
				if attr == nil {
					continue
				}

				field := Field{
					Name: noLowerCaser.String(field.Tag),
					Type: dmlToGoType(attr.Value),
				}

				msg.Fields = append(msg.Fields, field)
			}
		}

		// Default to using the index of the message as the MsgOrder if unspecified
		if msg.Meta.MsgOrder == "" {
			msg.Meta.MsgOrder = fmt.Sprint(n + 1)
		}

		p.Messages = append(p.Messages, msg)
	}

	return nil
}

func readProtocolInfo(doc *etree.Document, p *Protocol) error {
	record := doc.FindElement("//_ProtocolInfo/RECORD")
	if record == nil {
		return ErrMissingProtocolInfo
	}

	search := map[string]string{
		"ServiceID":           "",
		"ProtocolType":        "",
		"ProtocolVersion":     "",
		"ProtocolDescription": "",
	}
	for k := range search {
		val := record.FindElement(k)
		if val == nil {
			return ErrMissingProtocolInfo
		}
		search[k] = val.Text()
	}

	p.Meta.ServiceID = search["ServiceID"]
	p.Meta.Type = search["ProtocolType"]
	p.Meta.Version = search["ProtocolVersion"]
	p.Meta.Description = search["ProtocolDescription"]

	p.Service = lowerCaser.String(p.Meta.Type)

	return nil
}

func dmlToGoType(typ string) string {
	switch typ {
	case "BYT":
		return "int8"
	case "UBYT":
		return "uint8"
	case "SHRT":
		return "int16"
	case "USHRT":
		return "uint16"
	case "INT":
		return "int32"
	case "UINT":
		return "uint32"
	case "STR":
		return "string"
	case "WSTR":
		// TODO: Think about this
		return "string"
	case "FLT":
		return "float32"
	case "DBL":
		return "float64"
	case "GID":
		return "uint64"
	default:
		// TODO: Don't panic!
		panic(fmt.Sprintf("unknown DML type %v", typ))
	}
}
