package codegen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"slices"
	"strings"

	"github.com/beevik/etree"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type DMLType string

var dmlTypes = []DMLType{
	dmlByt, dmlUbyt, dmlShrt, dmlUshrt, dmlInt, dmlUint, dmlStr, dmlWstr,
	dmlFlt, dmlDbl, dmlGid, dmlBool,
}

var dmlAsGoTypes = map[DMLType]goType{
	dmlByt:   goInt8,
	dmlUbyt:  goUint8,
	dmlShrt:  goInt16,
	dmlUshrt: goUint16,
	dmlInt:   goInt32,
	dmlUint:  goUint32,
	dmlStr:   goString,
	dmlWstr:  goString,
	dmlFlt:   goFloat32,
	dmlDbl:   goFloat64,
	dmlGid:   goUint64,
	dmlBool:  goBool,
}

const (
	dmlByt   DMLType = "BYT"
	dmlUbyt  DMLType = "UBYT"
	dmlShrt  DMLType = "SHRT"
	dmlUshrt DMLType = "USHRT"
	dmlInt   DMLType = "INT"
	dmlUint  DMLType = "UINT"
	dmlStr   DMLType = "STR"
	dmlWstr  DMLType = "WSTR"
	dmlFlt   DMLType = "FLT"
	dmlDbl   DMLType = "DBL"
	dmlGid   DMLType = "GID"
	dmlBool  DMLType = "BOOL"
)

type goType string

const (
	goInt8    goType = "int8"
	goUint8   goType = "uint8"
	goInt16   goType = "int16"
	goUint16  goType = "uint16"
	goInt32   goType = "int32"
	goUint32  goType = "uint32"
	goString  goType = "string"
	goFloat32 goType = "float32"
	goFloat64 goType = "float64"
	goUint64  goType = "uint64"
	goBool    goType = "bool"
)

var (
	ErrMissingProtocolInfo = errors.New("codegen: failed to locate protocol info")
	ErrMissingRecords      = errors.New("codegen: failed to locate records")
	ErrInvalidRecord       = errors.New("codegen: record is not valid")
	ErrInvalidMessage      = errors.New("codegen: message is not valid")
	ErrNoGoPackageEnv      = errors.New("codegen: $GOPACKAGE was not set in environment")
)

var (
	lowerCaser   = cases.Title(language.English)
	noLowerCaser = cases.Title(language.English, cases.NoLower)
)

type Field struct {
	Name string
	Type DMLType
}

type Message struct {
	Type string
	Meta struct {
		MsgOrder       string
		MsgName        string
		MsgDescription string
		MsgHandler     string
		MsgAccessLvl   string
	}
	Fields []Field
}

type Protocol struct {
	Package string
	Service string
	Meta    struct {
		ServiceID   string
		Type        string
		Version     string
		Description string
	}
	Messages []Message
}

func ReadProtocol(file string) (Protocol, error) {
	doc := etree.NewDocument()

	if err := doc.ReadFromFile(file); err != nil {
		return Protocol{}, err
	}

	var pr Protocol
	if err := readProtocol(doc, &pr); err != nil {
		return Protocol{}, err
	}

	return pr, nil
}

func UnmarshalProtocol(data []byte) (Protocol, error) {
	doc := etree.NewDocument()

	if err := doc.ReadFromBytes(data); err != nil {
		return Protocol{}, err
	}

	var pr Protocol
	if err := readProtocol(doc, &pr); err != nil {
		return Protocol{}, err
	}

	return pr, nil
}

func Generate(w io.Writer, pr Protocol) error {
	var b bytes.Buffer

	p(&b, "// Code generated by w101-client-go. DO NOT EDIT.")
	p(&b, "package ", pr.Package)

	p(&b, "import (")
	p(&b, `"`, "github.com/cedws/w101-client-go/proto", `"`)
	p(&b, `"bytes"`)
	p(&b, `"encoding/binary"`)
	p(&b, `"unsafe"`)
	p(&b, ")")

	p(&b, "type ", unexport(pr.Service), "Service interface {")
	for _, msg := range pr.Messages {
		p(&b, msg.Type, "(", msg.Type, ")")
	}
	p(&b, "}")

	p(&b)

	p(&b, "type ", pr.Service, "Service struct {")
	p(&b, unexport(pr.Service), "Service")
	p(&b, "}")

	p(&b)

	p(&b, "type ", pr.Service, "Client struct {")
	p(&b, "c *proto.Client")
	p(&b, "}")

	for _, msg := range pr.Messages {
		p(&b, "func (l *", pr.Service, "Service) ", msg.Type, "(_ ", msg.Type, ") {}")
	}

	p(&b)

	p(&b, "func Register", pr.Service, "Service(r *proto.MessageRouter, s ", unexport(pr.Service), "Service) {")
	for _, msg := range pr.Messages {
		p(&b, "proto.RegisterMessageHandler(r, ", pr.Meta.ServiceID, ",", msg.Meta.MsgOrder, ",", "s.", msg.Type, ")")
	}
	p(&b, "}")

	p(&b)

	p(&b, "func New", pr.Service, "Client(c *proto.Client) ", pr.Service, "Client {")
	p(&b, "return ", pr.Service, "Client{c}")
	p(&b, "}")

	for _, msg := range pr.Messages {
		p(&b)
		p(&b, "func (c ", pr.Service, "Client) ", msg.Type, "(m *", msg.Type, ") error {")
		p(&b, "return c.c.WriteMessage(", pr.Meta.ServiceID, ",", msg.Meta.MsgOrder, ", m)")
		p(&b, "}")
	}

	writeMessages(&b, pr)
	p(&b)
	writeFuncs(&b, pr)

	if err := reformat(&b, w); err != nil {
		return err
	}

	return nil
}

func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func pf(w io.Writer, args ...string) {
	fmt.Fprintf(w, strings.Join(args, ""))
}

func p(w io.Writer, args ...string) {
	fmt.Fprintln(w, strings.Join(args, ""))
}

func reformat(in *bytes.Buffer, out io.Writer) error {
	fmtd, err := format.Source(in.Bytes())
	if err != nil {
		return err
	}

	_, err = out.Write(fmtd)
	return err
}

func msgBaseSize(msg Message) (size int) {
	for _, field := range msg.Fields {
		switch DMLType(field.Type) {
		case dmlByt:
			size += 1
		case dmlUbyt:
			size += 1
		case dmlShrt:
			size += 2
		case dmlUshrt:
			size += 2
		case dmlInt:
			size += 4
		case dmlUint:
			size += 4
		case dmlStr:
			// variable length, add 2 bytes for length prefix
			size += 2
		case dmlWstr:
			// variable length, add 2 bytes for length prefix
			size += 2
		case dmlFlt:
			size += 4
		case dmlDbl:
			size += 8
		case dmlGid:
			size += 8
		default:
			panic(fmt.Sprintf("codegen: unknown field type %v", field.Type))
		}
	}

	return
}

func writeMessages(b io.Writer, pr Protocol) {
	for _, msg := range pr.Messages {
		p(b, "type ", msg.Type, " struct {")
		for _, field := range msg.Fields {
			goType, ok := dmlAsGoTypes[field.Type]
			if !ok {
				panic(fmt.Sprintf("codegen: unknown field type %v", field.Type))
			}

			p(b, field.Name, " ", string(goType))
		}
		p(b, "}")

		generateMarshalBinary(b, pr, msg)
		p(b)
		generateUnmarshalBinary(b, pr, msg)
	}
}

func generateMarshalBinary(b io.Writer, pr Protocol, msg Message) {
	p(b, "func (s *", msg.Type, ") MarshalBinary() ([]byte, error) {")

	if len(msg.Fields) == 0 {
		p(b, "return []byte{}, nil")
		p(b, "}")

		return
	}

	baseSize := msgBaseSize(msg)

	pf(b, "b := bytes.NewBuffer(make([]byte, 0, ", fmt.Sprint(baseSize))
	for _, field := range msg.Fields {
		switch field.Type {
		case dmlStr, dmlWstr:
			pf(b, "+len(s.", field.Name, ")")
		}
	}
	p(b, "))")

	for _, field := range msg.Fields {
		switch field.Type {
		case dmlStr, dmlWstr:
			p(b, "writeString_", pr.Meta.ServiceID, "(b, s.", field.Name, ")")
		default:
			p(b, "binary.Write(b, binary.LittleEndian, s.", field.Name, ")")
		}

	}

	p(b, "return b.Bytes(), nil")
	p(b, "}")
}

func generateUnmarshalBinary(b io.Writer, pr Protocol, msg Message) {
	p(b, "func (s *", msg.Type, ") UnmarshalBinary(data []byte) error {")

	if len(msg.Fields) == 0 {
		p(b, "return nil")
		p(b, "}")

		return
	}

	p(b, "b := bytes.NewReader(data)")
	p(b, "var err error")

	for _, field := range msg.Fields {
		switch field.Type {
		case dmlStr, dmlWstr:
			p(b, "if s.", field.Name, ", err = readString_", pr.Meta.ServiceID, "(b); err != nil {")
			p(b, "return err")
			p(b, "}")
		default:
			p(b, "if err = binary.Read(b, binary.LittleEndian, &s.", field.Name, "); err != nil {")
			p(b, "return err")
			p(b, "}")
		}
	}

	p(b, "return nil")
	p(b, "}")
}

func writeFuncs(b io.Writer, pr Protocol) {
	// funcs are prefixed with service ID to avoid conflicts when multiple files are generated
	// within the same go package

	p(b, "func writeString_", pr.Meta.ServiceID, "(b *bytes.Buffer, v string) {")
	p(b, "binary.Write(b, binary.LittleEndian, uint16(len(v)))")
	p(b, "b.WriteString(v)")
	p(b, "}")

	p(b)

	p(b, "func readString_", pr.Meta.ServiceID, "(buf *bytes.Reader) (string, error) {")
	p(b, "var length uint16")
	p(b, "if err := binary.Read(buf, binary.LittleEndian, &length); err != nil {")
	p(b, `return "", err`)
	p(b, "}")
	p(b, "data := make([]byte, length)")
	p(b, "if _, err := buf.Read(data); err != nil {")
	p(b, `return "", err`)
	p(b, "}")
	p(b, "return *(*string)(unsafe.Pointer(&data)), nil")
	p(b, "}")
}

func readProtocol(doc *etree.Document, p *Protocol) error {
	p.Package = os.Getenv("GOPACKAGE")
	if p.Package == "" {
		return ErrNoGoPackageEnv
	}

	if err := readProtocolInfo(doc, p); err != nil {
		return err
	}

	if err := readMessages(doc, p); err != nil {
		return err
	}

	return nil
}

func readMessages(doc *etree.Document, p *Protocol) error {
	records := doc.FindElements("//RECORD")
	if records == nil {
		return ErrMissingRecords
	}

	if len(records) == 0 {
		return ErrInvalidRecord
	}

	// Skip first record which is protocol info
	for n, record := range records[1:] {
		fields := record.FindElements("*")
		if fields == nil {
			return ErrInvalidRecord
		}

		var msg Message

		for _, field := range fields {
			txt := field.Text()

			switch field.Tag {
			case "_MsgOrder":
				msg.Meta.MsgOrder = txt
			case "_MsgName":
				msg.Meta.MsgName = txt
			case "_MsgDescription":
				msg.Meta.MsgDescription = txt
			case "_MsgHandler":
				// Use the handler name as the message type because it's already PascalCased for us
				msg.Type = strings.ReplaceAll(txt[4:], "_", "")
				msg.Meta.MsgHandler = txt
			case "_MsgAccessLvl":
				msg.Meta.MsgAccessLvl = txt
			default:
				attr := field.SelectAttr("TYPE")
				if attr == nil {
					continue
				}

				dmlType, ok := parseDMLType(attr.Value)
				if !ok {
					return fmt.Errorf("%w: invalid type %v", ErrInvalidMessage, attr.Value)
				}

				field := Field{
					Name: noLowerCaser.String(field.Tag),
					Type: dmlType,
				}

				msg.Fields = append(msg.Fields, field)
			}
		}

		// Default to using the index of the message as the MsgOrder if unspecified
		if msg.Meta.MsgOrder == "" {
			msg.Meta.MsgOrder = fmt.Sprint(n + 1)
		}

		p.Messages = append(p.Messages, msg)
	}

	return nil
}

func readProtocolInfo(doc *etree.Document, p *Protocol) error {
	record := doc.FindElement("//_ProtocolInfo/RECORD")
	if record == nil {
		return ErrMissingProtocolInfo
	}

	search := map[string]string{
		"ServiceID":           "",
		"ProtocolType":        "",
		"ProtocolVersion":     "",
		"ProtocolDescription": "",
	}
	for k := range search {
		val := record.FindElement(k)
		if val == nil {
			return ErrMissingProtocolInfo
		}
		search[k] = val.Text()
	}

	p.Meta.ServiceID = search["ServiceID"]
	p.Meta.Type = search["ProtocolType"]
	p.Meta.Version = search["ProtocolVersion"]
	p.Meta.Description = search["ProtocolDescription"]

	p.Service = lowerCaser.String(p.Meta.Type)

	return nil
}

func parseDMLType(dmlType string) (DMLType, bool) {
	if d := DMLType(dmlType); slices.Contains(dmlTypes, d) {
		return d, true
	}

	return "", false
}
