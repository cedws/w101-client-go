package codegen

import (
	"bytes"
	"cmp"
	"errors"
	"fmt"
	"go/format"
	"io"
	"slices"
	"strconv"
	"strings"

	"github.com/beevik/etree"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type DMLType string

var dmlTypes = []DMLType{
	dmlByt, dmlUbyt, dmlShrt, dmlUshrt, dmlInt, dmlUint, dmlStr, dmlWstr,
	dmlFlt, dmlDbl, dmlGid, dmlBool,
}

var dmlAsGoTypes = map[DMLType]goType{
	dmlByt:   goInt8,
	dmlUbyt:  goUint8,
	dmlShrt:  goInt16,
	dmlUshrt: goUint16,
	dmlInt:   goInt32,
	dmlUint:  goUint32,
	dmlStr:   goString,
	dmlWstr:  goString,
	dmlFlt:   goFloat32,
	dmlDbl:   goFloat64,
	dmlGid:   goUint64,
	dmlBool:  goBool,
}

const (
	dmlByt   DMLType = "BYT"
	dmlUbyt  DMLType = "UBYT"
	dmlShrt  DMLType = "SHRT"
	dmlUshrt DMLType = "USHRT"
	dmlInt   DMLType = "INT"
	dmlUint  DMLType = "UINT"
	dmlStr   DMLType = "STR"
	dmlWstr  DMLType = "WSTR"
	dmlFlt   DMLType = "FLT"
	dmlDbl   DMLType = "DBL"
	dmlGid   DMLType = "GID"
	dmlBool  DMLType = "BOOL"
)

type goType string

const (
	goInt8    goType = "int8"
	goUint8   goType = "uint8"
	goInt16   goType = "int16"
	goUint16  goType = "uint16"
	goInt32   goType = "int32"
	goUint32  goType = "uint32"
	goString  goType = "string"
	goFloat32 goType = "float32"
	goFloat64 goType = "float64"
	goUint64  goType = "uint64"
	goBool    goType = "bool"
)

var (
	ErrMissingProtocolInfo = errors.New("codegen: failed to locate protocol info")
	ErrMissingRecords      = errors.New("codegen: failed to locate records")
	ErrInvalidRecord       = errors.New("codegen: record is not valid")
	ErrInvalidMessage      = errors.New("codegen: message is not valid")
	ErrNoGoPackageEnv      = errors.New("codegen: $GOPACKAGE was not set in environment")
)

var (
	titleCaser        = cases.Title(language.English)
	titleCaserNoLower = cases.Title(language.English, cases.NoLower)
)

type Field struct {
	Name string
	Type DMLType
}

type Message struct {
	Type   string
	Tag    string
	Fields []Field
	Meta   struct {
		MsgOrder       int
		MsgName        string
		MsgDescription string
		MsgHandler     string
		MsgAccessLvl   string
	}
}

type Protocol struct {
	Service string
	Meta    struct {
		ServiceID   string
		Type        string
		Version     string
		Description string
	}
	Messages []Message
}

func ReadProtocol(file string) (Protocol, error) {
	doc := etree.NewDocument()

	if err := doc.ReadFromFile(file); err != nil {
		return Protocol{}, err
	}

	var pr Protocol
	if err := readProtocol(doc, &pr); err != nil {
		return Protocol{}, err
	}

	return pr, nil
}

func UnmarshalProtocol(data []byte) (Protocol, error) {
	doc := etree.NewDocument()

	if err := doc.ReadFromBytes(data); err != nil {
		return Protocol{}, err
	}

	var pr Protocol
	if err := readProtocol(doc, &pr); err != nil {
		return Protocol{}, err
	}

	return pr, nil
}

func Generate(w io.Writer, packageName string, pr Protocol) error {
	var b bytes.Buffer

	importBytes := func() bool {
		for _, msg := range pr.Messages {
			if len(msg.Fields) > 0 {
				return true
			}
		}

		return false
	}

	importCodegen := func() bool {
		for _, msg := range pr.Messages {
			for _, field := range msg.Fields {
				if dmlStringType(field.Type) {
					return true
				}
			}
		}

		return false
	}

	importBinary := func() bool {
		for _, msg := range pr.Messages {
			for _, field := range msg.Fields {
				if dmlStringType(field.Type) {
					return true
				}
			}
		}

		return false
	}

	p(&b, "// Code generated by w101-client-go. DO NOT EDIT.")
	p(&b, "package ", packageName)

	p(&b, "import (")
	if importBytes() {
		p(&b, `"bytes"`)
	}
	if importCodegen() {
		p(&b, `"`, "github.com/cedws/w101-client-go/codegen", `"`)
	}
	if importBinary() {
		p(&b, `"encoding/binary"`)
	}
	p(&b, `"`, "github.com/cedws/w101-client-go/proto", `"`)
	p(&b, ")")

	p(&b, "type service interface {")
	for _, msg := range pr.Messages {
		p(&b, msg.Type, "(", msg.Type, ")")
	}
	p(&b, "}")

	p(&b)

	for _, msg := range pr.Messages {
		p(&b, "func (Service) ", msg.Type, "(", msg.Type, ") {}")
	}

	p(&b)

	p(&b, "func RegisterService(r *proto.MessageRouter, s service) {")
	for _, msg := range pr.Messages {
		p(&b, "proto.RegisterMessageHandler(r, ", pr.Meta.ServiceID, ",", fmt.Sprint(msg.Meta.MsgOrder), ",", "s.", msg.Type, ")")
	}
	p(&b, "}")

	p(&b)

	p(&b, "func NewClient(c *proto.Client) Client {")
	p(&b, "return Client{c}")
	p(&b, "}")

	for _, msg := range pr.Messages {
		p(&b)
		p(&b, "func (c Client) ", msg.Type, "(m *", msg.Type, ") error {")
		p(&b, "return c.c.WriteMessage(", pr.Meta.ServiceID, ",", fmt.Sprint(msg.Meta.MsgOrder), ", m)")
		p(&b, "}")
	}

	p(&b)

	generateStructs(&b, pr.Messages)

	if err := reformat(&b, w); err != nil {
		io.Copy(w, &b)
		return err
	}

	return nil
}

func parseDMLType(dmlType string) (DMLType, bool) {
	if d := DMLType(dmlType); slices.Contains(dmlTypes, d) {
		return d, true
	}

	return "", false
}

func dmlStringType(dmlType DMLType) bool {
	return dmlType == dmlStr || dmlType == dmlWstr
}

func dmlTypeSize(dmlType DMLType) int {
	switch dmlType {
	case dmlByt:
		return 1
	case dmlUbyt:
		return 1
	case dmlShrt:
		return 2
	case dmlUshrt:
		return 2
	case dmlInt:
		return 4
	case dmlUint:
		return 4
	case dmlStr:
		// variable length, add 2 bytes for length prefix
		return 2
	case dmlWstr:
		// variable length, add 2 bytes for length prefix
		return 2
	case dmlFlt:
		return 4
	case dmlDbl:
		return 8
	case dmlGid:
		return 8
	case dmlBool:
		return 1
	default:
		panic(fmt.Sprintf("codegen: unhandled field type %v", dmlType))
	}
}

func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func pf(w io.Writer, args ...string) {
	fmt.Fprintf(w, strings.Join(args, ""))
}

func p(w io.Writer, args ...string) {
	fmt.Fprintln(w, strings.Join(args, ""))
}

func reformat(in *bytes.Buffer, out io.Writer) error {
	fmtd, err := format.Source(in.Bytes())
	if err != nil {
		return err
	}

	_, err = out.Write(fmtd)
	return err
}

func msgBaseSize(msg Message) (size int) {
	for _, field := range msg.Fields {
		size += dmlTypeSize(field.Type)
	}

	return
}

func compareFieldSize(a, b Field) int {
	if dmlStringType(a.Type) {
		return -1
	}

	if dmlStringType(b.Type) {
		return 1
	}

	sizeA := dmlTypeSize(a.Type)
	sizeB := dmlTypeSize(b.Type)

	return cmp.Compare(sizeA, sizeB) * -1
}

func generateStructs(b io.Writer, msgs []Message) {
	p(b, "type Service struct {")
	p(b, "service")
	p(b, "}")

	p(b)

	p(b, "type Client struct {")
	p(b, "c *proto.Client")
	p(b, "}")

	for _, msg := range msgs {
		generateStruct(b, msg)
	}
}

func generateStruct(b io.Writer, msg Message) {
	p(b, "type ", msg.Type, " struct {")

	fields := make([]Field, len(msg.Fields))
	copy(fields, msg.Fields)

	// Sort fields by size to optimise alignment, strings come first
	slices.SortFunc(fields, compareFieldSize)

	for _, field := range fields {
		goType, ok := dmlAsGoTypes[field.Type]
		if !ok {
			panic(fmt.Sprintf("codegen: unknown field type %v", field.Type))
		}

		p(b, field.Name, " ", string(goType))
	}
	p(b, "}")

	generateMarshal(b, msg)
	p(b)
	generateUnmarshal(b, msg)
}

func generateMarshal(b io.Writer, msg Message) {
	p(b, "func (s *", msg.Type, ") Marshal() []byte {")

	if len(msg.Fields) == 0 {
		p(b, "return []byte{}")
		p(b, "}")

		return
	}

	baseSize := msgBaseSize(msg)

	pf(b, "b := bytes.NewBuffer(make([]byte, 0, ", fmt.Sprint(baseSize))
	for _, field := range msg.Fields {
		if dmlStringType(field.Type) {
			pf(b, "+len(s.", field.Name, ")")
		}
	}
	p(b, "))")

	for _, field := range msg.Fields {
		if dmlStringType(field.Type) {
			p(b, "binary.Write(b, binary.LittleEndian, s.", field.Name, ")")
		}
	}

	p(b, "return b.Bytes()")
	p(b, "}")
}

func generateUnmarshal(b io.Writer, msg Message) {
	p(b, "func (s *", msg.Type, ") Unmarshal(data []byte) error {")

	if len(msg.Fields) == 0 {
		p(b, "return nil")
		p(b, "}")

		return
	}

	p(b, "b := bytes.NewReader(data)")
	p(b, "var err error")

	for _, field := range msg.Fields {
		switch field.Type {
		case dmlStr, dmlWstr:
			p(b, "if s.", field.Name, ", err = codegen.ReadString(b); err != nil {")
			p(b, "return err")
			p(b, "}")
		default:
			p(b, "if err = binary.Read(b, binary.LittleEndian, &s.", field.Name, "); err != nil {")
			p(b, "return err")
			p(b, "}")
		}
	}

	p(b, "return nil")
	p(b, "}")
}

func readProtocol(doc *etree.Document, p *Protocol) error {
	if err := readProtocolInfo(doc, p); err != nil {
		return err
	}

	if err := readMessages(doc, p); err != nil {
		return err
	}

	return nil
}

func compareMessageByTag(a, b Message) int {
	return strings.Compare(a.Tag, b.Tag)
}

func compareMessageByOrder(a, b Message) int {
	return a.Meta.MsgOrder - b.Meta.MsgOrder
}

func dedupeMessagesByTag(messages []Message) []Message {
	msgs := make([]Message, 0, len(messages))
	msgNames := make([]string, 0, len(messages))

	for _, msg := range messages {
		if slices.Contains(msgNames, msg.Meta.MsgName) {
			continue
		}

		msgs = append(msgs, msg)
		msgNames = append(msgNames, msg.Meta.MsgName)
	}

	return msgs
}

func readMessages(doc *etree.Document, p *Protocol) error {
	records := doc.FindElements("//RECORD")
	if records == nil {
		return ErrMissingRecords
	}

	if len(records) == 0 {
		return ErrInvalidRecord
	}

	// Skip first record which is protocol info
	for _, record := range records[1:] {
		parent := record.Parent()
		if parent == nil {
			return ErrInvalidRecord
		}

		msg := Message{
			Tag: parent.Tag,
		}

		if err := readMessageOrder(record, &msg); err != nil {
			return err
		}

		if err := readMessageName(record, &msg); err != nil {
			return err
		}

		if err := readMessageDescription(record, &msg); err != nil {
			return err
		}

		if err := readMessageHandler(record, &msg); err != nil {
			return err
		}

		fields := record.FindElements("*")
		if fields == nil {
			return ErrInvalidRecord
		}

		for _, field := range fields {
			if field.SelectAttr("NOXFER") != nil {
				continue
			}

			attr := field.SelectAttr("TYPE")
			if attr == nil {
				continue
			}

			dmlType, ok := parseDMLType(attr.Value)
			if !ok {
				return fmt.Errorf("%w: invalid type %v", ErrInvalidMessage, attr.Value)
			}

			field := Field{
				Name: titleCaserNoLower.String(field.Tag),
				Type: dmlType,
			}

			msg.Fields = append(msg.Fields, field)
		}

		p.Messages = append(p.Messages, msg)
	}

	p.Messages = dedupeMessagesByTag(p.Messages)

	// Sort messages by tag
	slices.SortFunc(p.Messages, compareMessageByTag)

	for i, msg := range p.Messages {
		// If no explicit MsgOrder, use the implicit order from sorted slice
		// MsgOrder is 1-indexed, so zero value is unset
		if msg.Meta.MsgOrder == 0 {
			p.Messages[i].Meta.MsgOrder = i + 1
		}
	}

	// Sort messages by order
	slices.SortFunc(p.Messages, compareMessageByOrder)

	return nil
}

func readMessageOrder(record *etree.Element, msg *Message) error {
	fields := record.FindElement("_MsgOrder[@NOXFER='TRUE']")
	if fields == nil {
		// MsgOrder is optional
		return nil
	}
	order, err := strconv.ParseInt(fields.Text(), 10, 64)
	if err != nil {
		return fmt.Errorf("%w: invalid message order %v", ErrInvalidMessage, fields.Text())
	}
	msg.Meta.MsgOrder = int(order)
	return nil
}

func readMessageName(record *etree.Element, msg *Message) error {
	field := record.FindElement("_MsgName[@NOXFER='TRUE']")
	if field == nil {
		return ErrInvalidRecord
	}
	msg.Meta.MsgName = field.Text()
	return nil
}

func readMessageDescription(record *etree.Element, msg *Message) error {
	field := record.FindElement("_MsgDescription[@NOXFER='TRUE']")
	if field == nil {
		return ErrInvalidRecord
	}
	msg.Meta.MsgDescription = field.Text()
	return nil
}

func readMessageHandler(record *etree.Element, msg *Message) error {
	field := record.FindElement("_MsgHandler[@NOXFER='TRUE']")
	if field == nil {
		return ErrInvalidRecord
	}
	msg.Type = strings.ReplaceAll(field.Text()[4:], "_", "")
	msg.Meta.MsgHandler = field.Text()
	return nil
}

func readProtocolInfo(doc *etree.Document, p *Protocol) error {
	record := doc.FindElement("//_ProtocolInfo/RECORD")
	if record == nil {
		return ErrMissingProtocolInfo
	}

	search := map[string]string{
		"ServiceID":           "",
		"ProtocolType":        "",
		"ProtocolVersion":     "",
		"ProtocolDescription": "",
	}
	for k := range search {
		val := record.FindElement(k)
		if val == nil {
			return ErrMissingProtocolInfo
		}
		search[k] = val.Text()
	}

	p.Meta.ServiceID = search["ServiceID"]
	p.Meta.Type = search["ProtocolType"]
	p.Meta.Version = search["ProtocolVersion"]
	p.Meta.Description = search["ProtocolDescription"]

	service := titleCaser.String(p.Meta.Type)
	service = strings.TrimSuffix(service, "_messages")
	service = strings.TrimSuffix(service, "messages")

	p.Service = service

	return nil
}
